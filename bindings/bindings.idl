// bindings.idl for wgpuEngine
// https://github.com/upf-gti/wgpuEngine

/*
*	Math
*/

[Prefix = "glm::"]
interface vec2 {
    void vec2();
    void vec2(float v);
    void vec2(float x, float y);
    attribute float x;
    attribute float y;
};

[Prefix = "glm::"]
interface vec3 {
	void vec3();
    void vec3(float v);
	void vec3(float x, float y, float z);
	attribute float x;
	attribute float y;
	attribute float z;
};

[Prefix = "glm::"]
interface vec4 {
    void vec4();
    void vec4(float v);
    void vec4(float x, float y, float z, float w);
    attribute float x;
    attribute float y;
    attribute float z;
    attribute float w;
};

[Prefix = "glm::"]
interface quat {
	void quat();
	void quat(float x, float y, float z, float w);
	attribute float x;
	attribute float y;
	attribute float z;
	attribute float w;
};

[Prefix = "glm::"]
interface mat4x4 {
    void mat4x4();
};

interface Transform {
  void Transform();
};

/*
*	Camera
*/

enum eCameraType {
	"CAMERA_ORBIT",
	"CAMERA_FLYOVER"
};

/*
*	Material and Surface
*/

enum eMaterialType {
    "MATERIAL_PBR",
    "MATERIAL_UNLIT",
    "MATERIAL_UI"
};

enum eTransparencyType {
    "ALPHA_OPAQUE",
    "ALPHA_BLEND",
    "ALPHA_MASK",
    "ALPHA_HASH"
};

enum eTopologyType {
    "TOPOLOGY_POINT_LIST",
    "TOPOLOGY_LINE_LIST",
    "TOPOLOGY_LINE_STRIP",
    "TOPOLOGY_TRIANGLE_LIST",
    "TOPOLOGY_TRIANGLE_STRIP"
};

enum eCullType {
    "CULL_NONE",
    "CULL_BACK",
    "CULL_FRONT"
};

interface Shader {
    void Shader();
};

interface Pipeline {
    void Pipeline();
};

interface Texture {
    void Texture();
};

interface Material {
    void Material();
    [BindTo = "set_color"] void setColor([Const, Ref] vec4 color);
    [BindTo = "set_roughness"] void setRoughness(float roughness);
    [BindTo = "set_metallic"] void setMetallic(float metallic);
    [BindTo = "set_occlusion"] void setOcclusion(float occlusion);
    [BindTo = "set_emissive"] void setEmissive([Const, Ref] vec3 emissive);
    [BindTo = "set_diffuse_texture"] void setDiffuseTexture(Texture diffuseTexture);
    [BindTo = "set_metallic_roughness_texture"] void setMetallicRoughnessTexture(Texture metallicRoughnessTexture);
    [BindTo = "set_normal_texture"] void setNormalTexture(Texture normalTexture);
    [BindTo = "set_emissive_texture"] void setEmissiveTexture(Texture emissiveTexture);
    [BindTo = "set_occlusion_texture"] void setOcclusionTexture(Texture occlusionTexture);
    [BindTo = "set_alpha_mask"] void setAlphaMask(float alphaMask);
    [BindTo = "set_depth_read_write"] void setDepthReadWrite(boolean value);
    [BindTo = "set_depth_read"] void setDepthRead(boolean depthRead);
    [BindTo = "set_depth_write"] void setDepthWrite(boolean depthWrite);
    [BindTo = "set_use_skinning"] void setUseSkinning(boolean useSkinning);
    [BindTo = "set_is_2D"] void setIs2D(boolean is2D);
    [BindTo = "set_fragment_write"] void setFragmentWrite(boolean fragmentWrite);
    [BindTo = "set_transparency_type"] void setTransparencyType(eTransparencyType transparencyType);
    [BindTo = "set_topology_type"] void setTopologyType(eTopologyType topologyType);
    [BindTo = "set_cull_type"] void setCullType(eCullType cullType);
    [BindTo = "set_type"] void setType(eMaterialType type);
    [BindTo = "set_priority"] void setPriority(short priority);
    [BindTo = "set_shader"] void setShader(Shader shader);
    [BindTo = "set_shader_pipeline"] void setShaderPipeline(Pipeline pipeline);
    [BindTo = "get_color", Value] vec4 getColor();
    [BindTo = "get_roughness"] float getRoughness();
    [BindTo = "get_metallic"] float getMetallic();
    [BindTo = "get_occlusion"] float getOcclusion();
    [BindTo = "get_emissive", Value] vec3 getEmissive();
    [BindTo = "get_diffuse_texture"] Texture getDiffuseTexture();
    [BindTo = "get_metallic_roughness_texture"] Texture getMetallicRoughnessTexture();
    [BindTo = "get_normal_texture"] Texture getNormalTexture();
    [BindTo = "get_emissive_texture"] Texture getEmissiveTexture();
    [BindTo = "get_occlusion_texture"] Texture getOcclusionTexture();
    [BindTo = "get_alpha_mask"] float getAlphaMask();
    [BindTo = "get_depth_read"] boolean getDepthRead();
    [BindTo = "get_depth_write"] boolean getDepthWrite();
    [BindTo = "get_use_skinning"] boolean getUseSkinning();
    [BindTo = "get_is_2D"] boolean getIs2D();
    [BindTo = "get_fragment_write"] boolean getFragmentWrite();
    [BindTo = "get_transparency_type"] eTransparencyType getTransparencyType();
    [BindTo = "get_topology_type"] eTopologyType getTopologyType();
    [BindTo = "get_cull_type"] eCullType getCullType();
    [BindTo = "get_type"] eMaterialType getType();
    [BindTo = "get_priority"] short getPriority();
    [BindTo = "get_shader", Const] Shader getShader();
    [BindTo = "get_shader_ref"] Shader getShaderRef();
};

interface Surface {
    void Surface();
    [BindTo = "create_quad"] void createQuad();
};

/*
*   Scene and Nodes
*/

interface Node {
    void Node();
    void render();
    void update(float deltaTime);
};

interface Node3D {
    void Node3D();
    void render();
    void update(float deltaTime);
    void translate([Const, Ref] vec3 translation);
    void scale([Const, Ref] vec3 scale);
    void rotate(float angle, [Const, Ref] vec3 axis);
    void rotate([Const, Ref] quat q);
    [BindTo = "rotate_world"] void rotateWorld([Const, Ref] quat q);
    [BindTo = "get_local_translation", Value] vec3 getLocalTranslation();
    [BindTo = "get_translation", Value] vec3 getTranslation();
    [BindTo = "get_global_model", Value] mat4x4 getGlobalModel();
    [BindTo = "get_model", Value] mat4x4 getModel();
    [BindTo = "get_rotation", Value] quat getRotation();
    [BindTo = "get_transform", Ref] Transform getTransform();
    [BindTo = "get_global_transform", Value] Transform getGlobalTransform();
    [BindTo = "set_position"] void setPosition([Const, Ref] vec3 translation);
    [BindTo = "set_rotation"] void setRotation([Const, Ref] quat rotation);
    [BindTo = "set_scale"] void setScale([Const, Ref] vec3 scale);
    [BindTo = "set_global_transform"] void setGlobalTransform([Const, Ref] Transform newTransform);
    [BindTo = "set_transform"] void setTransform([Const, Ref] Transform newTransform);
    [BindTo = "set_transform_dirty"] void setTransformDirty(boolean value);
    [BindTo = "set_parent"] void setarent(Node3D node);
    // virtual void serialize(std::ofstream& binary_scene_file) override;
    // virtual void parse(std::ifstream& binary_scene_file) override;
};
Node3D implements Node;

interface MeshInstance {
    void MeshInstance();
};

interface MeshInstance3D {
    void MeshInstance3D();
    void render();
    void update(float deltaTime);
    [BindTo = "get_surface"] Surface getSurface(long surfaceIdx);
    [BindTo = "set_surface_material_override"] void setSurfaceMaterialOverride(Surface surface, Material material);
    [BindTo = "set_frustum_culling_enabled"] void setFrustumCullingEnabled(boolean value);
    [BindTo = "add_surface"] void addSurface(Surface surface);
};
MeshInstance3D implements Node3D;

interface Environment3D {
    void Environment3D();
    void update(float deltaTime);
};
Environment3D implements MeshInstance3D;

enum LightType {
    "LIGHT_UNDEFINED",
    "LIGHT_DIRECTIONAL",
    "LIGHT_OMNI",
    "LIGHT_SPOT"
};

interface Light3D {
    void render();
    [BindTo = "get_type"] LightType getType();
    [BindTo = "get_intensity"] float getIntensity();
    [BindTo = "get_color", Const, Ref] vec3 getColor();
    [BindTo = "get_fading_enabled"] boolean getFadingEnabled();
    [BindTo = "get_cast_shadows"] boolean getCastShadows();
    [BindTo = "get_range"] float getRange();
    [BindTo = "set_color"] void setColor([Const, Ref] vec3 color);
    [BindTo = "set_intensity"] void setIntensity(float value);
    [BindTo = "set_range"] void setRange(float value);
    [BindTo = "set_fading_enabled"] void setFadingEnabled(boolean value);
    [BindTo = "set_cast_shadows"] void setCastShadows(boolean value);
    /*
    void clone(Node* new_node, bool copy = true) override;
    void on_set_color();
    void create_shadow_data();
    WGPUTexture get_shadow_depth_texture() { return shadow_depth_texture; }
    WGPUTextureView get_shadow_depth_texture_view() { return shadow_depth_texture_view; }
    void serialize(std::ofstream& binary_scene_file) override;
    void parse(std::ifstream& binary_scene_file) override;
    */
};
Light3D implements Node3D;

interface DirectionalLight3D {
    void DirectionalLight3D();
};
DirectionalLight3D implements Light3D;

interface SpotLight3D {
    void SpotLight3D();
};
SpotLight3D implements Light3D;

interface OmniLight3D {
    void OmniLight3D();
};
OmniLight3D implements Light3D;

interface Scene {
    void Scene();
    void update(float deltaTime);
    void render();
    void add_node(Node node, long idx);
    // void add_nodes(const std::vector<Node*>& nodes_to_add, int idx);
    [BindTo = "remove_node"] void removeNode(Node node);
    // void set_name(const std::string& name);
    // std::vector<Node*>& get_nodes();
    // const std::string& get_name() { return name; }
    [BindTo = "delete_all"] void deleteAll();
    // void serialize(const std::string& path);
    // void parse(const std::string& path);
};

/*
*	Renderer
*/

interface sRendererConfiguration {
	void sRendererConfiguration();
	// WGPULimits required_limits = {};
	// std::vector<WGPUFeatureName> features;
};

interface Renderer {
	void Renderer([Const, Ref] sRendererConfiguration configuration);
};

enum TextureStorageFlags {
    "TEXTURE_STORAGE_NONE",
    "TEXTURE_STORAGE_SRGB",
    "TEXTURE_STORAGE_KEEP_MEMORY",
    "TEXTURE_STORAGE_STORE_DATA",
    "TEXTURE_STORAGE_UI"
};

interface RendererStorage {
    static Surface get_surface(DOMString mesh_path);
    static Texture get_texture(DOMString shader_name, TextureStorageFlags flags);
    static Shader get_shader_from_name(DOMString shader_name, [Const] Material material);
};

/*
*	Engine
*/

interface sEngineConfiguration {
	void sEngineConfiguration();
	// attribute long window_width;
	// attribute long window_height;
	attribute eCameraType camera_type;
	[Value] attribute vec3 camera_eye;
	[Value] attribute vec3 camera_center;
	attribute short msaa_count;
	// attribute boolean fullscreen;
};

interface Engine {
	void Engine();
	long initialize(Renderer renderer, [Const, Ref] sEngineConfiguration configuration);
    [BindTo = "set_wasm_module_initialized"] void setWasmModuleInitialized(boolean value);
    [BindTo = "get_instance"] static Engine getInstance();
    [BindTo = "get_main_scene"] Scene getMainScene();
};